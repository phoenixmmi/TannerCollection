/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_webp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/webp.js */ \"./src/js/modules/webp.js\");\n/* harmony import */ var _modules_navigation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/navigation.js */ \"./src/js/modules/navigation.js\");\n/* harmony import */ var _modules_animations_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/animations.js */ \"./src/js/modules/animations.js\");\n/* harmony import */ var _modules_headerFixation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/headerFixation.js */ \"./src/js/modules/headerFixation.js\");\n/* harmony import */ var _modules_dynamicAdaptive_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/dynamicAdaptive.js */ \"./src/js/modules/dynamicAdaptive.js\");\n/* harmony import */ var _modules_burger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/burger.js */ \"./src/js/modules/burger.js\");\n/* harmony import */ var _modules_ibg_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/ibg.js */ \"./src/js/modules/ibg.js\");\n/* harmony import */ var _modules_mainSlider_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/mainSlider.js */ \"./src/js/modules/mainSlider.js\");\n/* harmony import */ var _modules_bagSlider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/bagSlider.js */ \"./src/js/modules/bagSlider.js\");\n/* harmony import */ var _modules_parallax_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/parallax.js */ \"./src/js/modules/parallax.js\");\n/* harmony import */ var _modules_jarallax_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/jarallax.js */ \"./src/js/modules/jarallax.js\");\n/* harmony import */ var _modules_jarallax_element_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/jarallax-element.js */ \"./src/js/modules/jarallax-element.js\");\n\r\n\r\n // преобразование картинок в webp\r\n // навигация по странице\r\n // анимация при скролле\r\n //фиксация шапки\r\n // динамический адаптив блоков\r\n //бургер меню\r\n //фича для картинок\r\n // mainSlider(Slider#1)\r\n // bagSlider(Slider#2)\r\n\r\n // parallax settings\r\n // jarallax\r\n // jarallax-element\r\n\r\n//!parallax\r\n(0,_modules_parallax_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\r\n\r\n//!навигация\r\n(0,_modules_navigation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\r\n\r\n//!Плавное появление блоков(Анимация)\r\n(0,_modules_animations_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\r\n\r\n//!Обработка изображений(Конвертирование в webp)\r\n(0,_modules_webp_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n\r\n//! BURGER\r\n(0,_modules_burger_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\r\n\r\n//! Фиксированная шапка\r\n(0,_modules_headerFixation_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\r\n\r\n//! Фича для изображений\r\n(0,_modules_ibg_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\r\n\r\n//! MAIN-SWIPER(SLIDER#1)======================================\r\n(0,_modules_mainSlider_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\r\n\r\n//!BAG-SLIDER(SLIDER#2)========================================\r\n(0,_modules_bagSlider_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/app.js?");

/***/ }),

/***/ "./src/js/modules/animations.js":
/*!**************************************!*\
  !*** ./src/js/modules/animations.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\r\n  const animItems = document.querySelectorAll(\"._anim-items\");\r\n  if (animItems.length > 0) {\r\n    window.addEventListener(\"scroll\", animOnScroll);\r\n    function animOnScroll() {\r\n      for (let index = 0; index < animItems.length; index++) {\r\n        const animItem = animItems[index];\r\n        const animItemHeight = animItem.offsetHeight;\r\n        const animItemOffset = offset(animItem).top;\r\n        const animStart = 70;\r\n\r\n        let animItemPoint = window.innerHeight - animItemHeight / animStart;\r\n        if (animItemHeight > window.innerHeight) {\r\n          animItemPoint = window.innerHeight - window.innerHeight / animStart;\r\n        }\r\n\r\n        if (\r\n          pageYOffset > animItemOffset - animItemPoint &&\r\n          pageYOffset < animItemOffset + animItemHeight\r\n        ) {\r\n          animItem.classList.add(\"_active\");\r\n        } else {\r\n          if (!animItem.classList.contains(\"_anim-no-hide\")) {\r\n            animItem.classList.remove(\"_active\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n    function offset(el) {\r\n      const rect = el.getBoundingClientRect(),\r\n        scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\r\n        scrollTop = window.pageYOffset || document.documentElement.scrollTop;\r\n      return { top: rect.top + scrollTop, left: rect.left + scrollLeft };\r\n    }\r\n    animOnScroll();\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/animations.js?");

/***/ }),

/***/ "./src/js/modules/bagSlider.js":
/*!*************************************!*\
  !*** ./src/js/modules/bagSlider.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => {\n  function createSwiper(nameBody, arrowPrev, arrowNext, pagination) {\n    let slider = 0;\n    return (slider = new Swiper(nameBody, {\n      breakpoints: {\n        320: {\n          slidesPerView: 1,\n        },\n        479: {\n          slidesPerView: 2,\n        },\n        767: {\n          slidesPerView: 4,\n        },\n      },\n      navigation: {\n        nextEl: arrowNext,\n        prevEl: arrowPrev,\n      },\n      slidesPerView: 4,\n      longSwipes: false,\n      loop: true,\n      pagination: {\n        el: pagination,\n        // Буллеты\n        clickable: true,\n        //Кастомные буллеты\n        renderBullet: function (index, className) {\n          return (\n            '<span class=\"' + className + '\">' + (\"0\" + (index + 1)) + \"</span>\"\n          );\n        },\n      },\n      keyboard: {\n        enabled: true,\n      },\n      keyPress: () => console.log(\"swiper\"),\n    }));\n  }\n\n  let bagSlider = createSwiper(\n    \".bag-slider__body\",\n    \".prev-first\",\n    \".next-first\",\n    \".pagination-first\"\n  );\n\n  let bagSliderSecond = createSwiper(\n    \".bag-slider__body-second\",\n    \".prev-second\",\n    \".next-second\",\n    \".pagination-second\"\n  );\n  let slidesView; // количество слайдов показывается\n  let paginationNumbersFirst = document.querySelectorAll(\n    \".pagination-first .swiper-pagination-bullet\"\n  );\n  let paginationWrapperFirst = document.querySelector(\".pagination-first\");\n\n  let paginationNumbersSecond = document.querySelectorAll(\n    \".pagination-second .swiper-pagination-bullet\"\n  );\n  let paginationWrapperSecond = document.querySelector(\".pagination-second\");\n\n  function slide(paginationActive, numbers, wrapper) {\n    let factor = Math.floor(numbers.length / 2) - paginationActive;\n    // 6.25 default\n    wrapper.style.transform = `translate(${6.25 * factor}rem)`;\n  }\n\n  slide(0, paginationNumbersFirst, paginationWrapperFirst); // пролистывание пагинации\n  slide(0, paginationNumbersSecond, paginationWrapperSecond); // пролистывание пагинации\n\n  sliderAct(bagSlider, paginationNumbersFirst, paginationWrapperFirst);\n  sliderAct(bagSliderSecond, paginationNumbersSecond, paginationWrapperSecond);\n\n  //! Событие на смену слайда любым способом\n  function sliderAct(sliderName, paginationNumbers, paginationWrapper) {\n    sliderName.on(\"slideChange\", function (e) {\n      //!bagSlider.activeIndex starts from 8\n      if (\n        sliderName.activeIndex - slidesView >=\n        sliderName.pagination.bullets.length\n      ) {\n        slide(0, paginationNumbers, paginationWrapper);\n      } else if (bagSlider.activeIndex - slidesView < 0) {\n        slide(\n          sliderName.pagination.bullets.length - 1,\n          paginationNumbers,\n          paginationWrapper\n        );\n      } else {\n        slide(\n          sliderName.activeIndex - slidesView,\n          paginationNumbers,\n          paginationWrapper\n        );\n      }\n    });\n  }\n\n  function slidesViewCheck() {\n    slidesView =\n      document.body.clientWidth <= 479\n        ? 1\n        : document.body.clientWidth <= 767\n        ? 2\n        : 4;\n  }\n  //Определяем количество показывающихся слайдов при загрузке.\n  window.addEventListener(\"load\", slidesViewCheck);\n  //Определяем количество показывающихся слайдов при изменении ширины страницы.\n  window.addEventListener(\"resize\", slidesViewCheck);\n});\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/bagSlider.js?");

/***/ }),

/***/ "./src/js/modules/burger.js":
/*!**********************************!*\
  !*** ./src/js/modules/burger.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\r\n  $(\".icon-menu\").click(function (event) {\r\n    $(this).toggleClass(\"_active\");\r\n    $(\".menu__body\").toggleClass(\"_active\");\r\n    $(\"body\").toggleClass(\"lock\");\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/burger.js?");

/***/ }),

/***/ "./src/js/modules/dynamicAdaptive.js":
/*!*******************************************!*\
  !*** ./src/js/modules/dynamicAdaptive.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// Dynamic Adapt v.1\r\n// HTML data-da=\"where(uniq class name),when(breakpoint),position(digi)\"\r\n// e.x. data-da=\".item,992,2\"\r\n// Andrikanych Yevhen 2020\r\n// https://www.youtube.com/c/freelancerlifestyle\r\n\r\n\r\n\r\nfunction DynamicAdapt(type) {\r\n  this.type = type;\r\n}\r\n\r\nDynamicAdapt.prototype.init = function () {\r\n  const _this = this;\r\n  // массив объектов\r\n  this.оbjects = [];\r\n  this.daClassname = \"_dynamic_adapt_\";\r\n  // массив DOM-элементов\r\n  this.nodes = document.querySelectorAll(\"[data-da]\");\r\n\r\n  // наполнение оbjects объктами\r\n  for (let i = 0; i < this.nodes.length; i++) {\r\n    const node = this.nodes[i];\r\n    const data = node.dataset.da.trim();\r\n    const dataArray = data.split(\",\");\r\n    const оbject = {};\r\n    оbject.element = node;\r\n    оbject.parent = node.parentNode;\r\n    оbject.destination = document.querySelector(dataArray[0].trim());\r\n    оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : \"767\";\r\n    оbject.place = dataArray[2] ? dataArray[2].trim() : \"last\";\r\n    оbject.index = this.indexInParent(оbject.parent, оbject.element);\r\n    this.оbjects.push(оbject);\r\n  }\r\n\r\n  this.arraySort(this.оbjects);\r\n\r\n  // массив уникальных медиа-запросов\r\n  this.mediaQueries = Array.prototype.map.call(\r\n    this.оbjects,\r\n    function (item) {\r\n      return (\r\n        \"(\" +\r\n        this.type +\r\n        \"-width: \" +\r\n        item.breakpoint +\r\n        \"px),\" +\r\n        item.breakpoint\r\n      );\r\n    },\r\n    this\r\n  );\r\n  this.mediaQueries = Array.prototype.filter.call(\r\n    this.mediaQueries,\r\n    function (item, index, self) {\r\n      return Array.prototype.indexOf.call(self, item) === index;\r\n    }\r\n  );\r\n\r\n  // навешивание слушателя на медиа-запрос\r\n  // и вызов обработчика при первом запуске\r\n  for (let i = 0; i < this.mediaQueries.length; i++) {\r\n    const media = this.mediaQueries[i];\r\n    const mediaSplit = String.prototype.split.call(media, \",\");\r\n    const matchMedia = window.matchMedia(mediaSplit[0]);\r\n    const mediaBreakpoint = mediaSplit[1];\r\n\r\n    // массив объектов с подходящим брейкпоинтом\r\n    const оbjectsFilter = Array.prototype.filter.call(\r\n      this.оbjects,\r\n      function (item) {\r\n        return item.breakpoint === mediaBreakpoint;\r\n      }\r\n    );\r\n    matchMedia.addListener(function () {\r\n      _this.mediaHandler(matchMedia, оbjectsFilter);\r\n    });\r\n    this.mediaHandler(matchMedia, оbjectsFilter);\r\n  }\r\n};\r\n\r\nDynamicAdapt.prototype.mediaHandler = function (matchMedia, оbjects) {\r\n  if (matchMedia.matches) {\r\n    for (let i = 0; i < оbjects.length; i++) {\r\n      const оbject = оbjects[i];\r\n      оbject.index = this.indexInParent(оbject.parent, оbject.element);\r\n      this.moveTo(оbject.place, оbject.element, оbject.destination);\r\n    }\r\n  } else {\r\n    for (let i = 0; i < оbjects.length; i++) {\r\n      const оbject = оbjects[i];\r\n      if (оbject.element.classList.contains(this.daClassname)) {\r\n        this.moveBack(оbject.parent, оbject.element, оbject.index);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Функция перемещения\r\nDynamicAdapt.prototype.moveTo = function (place, element, destination) {\r\n  element.classList.add(this.daClassname);\r\n  if (place === \"last\" || place >= destination.children.length) {\r\n    destination.insertAdjacentElement(\"beforeend\", element);\r\n    return;\r\n  }\r\n  if (place === \"first\") {\r\n    destination.insertAdjacentElement(\"afterbegin\", element);\r\n    return;\r\n  }\r\n  destination.children[place].insertAdjacentElement(\"beforebegin\", element);\r\n};\r\n\r\n// Функция возврата\r\nDynamicAdapt.prototype.moveBack = function (parent, element, index) {\r\n  element.classList.remove(this.daClassname);\r\n  if (parent.children[index] !== undefined) {\r\n    parent.children[index].insertAdjacentElement(\"beforebegin\", element);\r\n  } else {\r\n    parent.insertAdjacentElement(\"beforeend\", element);\r\n  }\r\n};\r\n\r\n// Функция получения индекса внутри родителя\r\nDynamicAdapt.prototype.indexInParent = function (parent, element) {\r\n  const array = Array.prototype.slice.call(parent.children);\r\n  return Array.prototype.indexOf.call(array, element);\r\n};\r\n\r\n// Функция сортировки массива по breakpoint и place\r\n// по возрастанию для this.type = min\r\n// по убыванию для this.type = max\r\nDynamicAdapt.prototype.arraySort = function (arr) {\r\n  if (this.type === \"min\") {\r\n    Array.prototype.sort.call(arr, function (a, b) {\r\n      if (a.breakpoint === b.breakpoint) {\r\n        if (a.place === b.place) {\r\n          return 0;\r\n        }\r\n\r\n        if (a.place === \"first\" || b.place === \"last\") {\r\n          return -1;\r\n        }\r\n\r\n        if (a.place === \"last\" || b.place === \"first\") {\r\n          return 1;\r\n        }\r\n\r\n        return a.place - b.place;\r\n      }\r\n\r\n      return a.breakpoint - b.breakpoint;\r\n    });\r\n  } else {\r\n    Array.prototype.sort.call(arr, function (a, b) {\r\n      if (a.breakpoint === b.breakpoint) {\r\n        if (a.place === b.place) {\r\n          return 0;\r\n        }\r\n\r\n        if (a.place === \"first\" || b.place === \"last\") {\r\n          return 1;\r\n        }\r\n\r\n        if (a.place === \"last\" || b.place === \"first\") {\r\n          return -1;\r\n        }\r\n\r\n        return b.place - a.place;\r\n      }\r\n\r\n      return b.breakpoint - a.breakpoint;\r\n    });\r\n    return;\r\n  }\r\n};\r\n\r\nconst da = new DynamicAdapt(\"max\");\r\nda.init();\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/dynamicAdaptive.js?");

/***/ }),

/***/ "./src/js/modules/headerFixation.js":
/*!******************************************!*\
  !*** ./src/js/modules/headerFixation.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\r\n  $(function () {\r\n    let header = $(\".header\");\r\n\r\n    $(window).scroll(function () {\r\n      if ($(this).scrollTop() > 1) {\r\n        header.addClass(\"header_fixed\");\r\n      } else {\r\n        header.removeClass(\"header_fixed\");\r\n      }\r\n    });\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/headerFixation.js?");

/***/ }),

/***/ "./src/js/modules/ibg.js":
/*!*******************************!*\
  !*** ./src/js/modules/ibg.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\r\n  $.each($(\".ibg\"), function (index, val) {\r\n    if ($(this).find(\"img\").length > 0) {\r\n      $(this).css(\r\n        \"background-image\",\r\n        'url(\"' + $(this).find(\"img\").attr(\"src\") + '\")'\r\n      );\r\n    }\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/ibg.js?");

/***/ }),

/***/ "./src/js/modules/jarallax-element.js":
/*!********************************************!*\
  !*** ./src/js/modules/jarallax-element.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/*!\n * DEPRECATED Elements Extension for Jarallax. Use lax.js instead https://github.com/alexfoxy/lax.js\n */\n\n(function (global, factory) {\n  typeof exports === \"object\" && typeof module !== \"undefined\"\n    ? (module.exports = factory())\n    : typeof define === \"function\" && define.amd\n    ? define(factory)\n    : ((global =\n        typeof globalThis !== \"undefined\" ? globalThis : global || self),\n      (global.jarallaxElement = factory()));\n})(undefined, function () {\n  \"use strict\";\n\n  function ready(callback) {\n    if (\n      \"complete\" === document.readyState ||\n      \"interactive\" === document.readyState\n    ) {\n      // Already ready or interactive, execute callback\n      callback();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", callback, {\n        capture: true,\n        once: true,\n        passive: true,\n      });\n    }\n  }\n\n  /* eslint-disable import/no-mutable-exports */\n\n  /* eslint-disable no-restricted-globals */\n  let win;\n\n  if (\"undefined\" !== typeof window) {\n    win = window;\n  } else if (\"undefined\" !== typeof global) {\n    win = global;\n  } else if (\"undefined\" !== typeof self) {\n    win = self;\n  } else {\n    win = {};\n  }\n\n  var global$1 = win;\n\n  function jarallaxElement(jarallax = global$1.jarallax) {\n    // eslint-disable-next-line no-console\n    // console.warn(\n    //   \"Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).\"\n    // );\n\n    if (\"undefined\" === typeof jarallax) {\n      return;\n    }\n\n    const Jarallax = jarallax.constructor; // redefine default methods\n\n    [\n      \"initImg\",\n      \"canInitParallax\",\n      \"init\",\n      \"destroy\",\n      \"coverImage\",\n      \"isVisible\",\n      \"onScroll\",\n      \"onResize\",\n    ].forEach((key) => {\n      const def = Jarallax.prototype[key];\n\n      Jarallax.prototype[key] = function (...args) {\n        const self = this;\n\n        if (\n          \"initImg\" === key &&\n          null !== self.$item.getAttribute(\"data-jarallax-element\")\n        ) {\n          self.options.type = \"element\";\n          self.pureOptions.speed =\n            self.$item.getAttribute(\"data-jarallax-element\") || \"100\";\n        }\n\n        if (\"element\" !== self.options.type) {\n          return def.apply(self, args);\n        }\n\n        self.pureOptions.threshold =\n          self.$item.getAttribute(\"data-threshold\") || \"\";\n\n        switch (key) {\n          case \"init\": {\n            const speedArr = `${self.pureOptions.speed}`.split(\" \");\n            self.options.speed = self.pureOptions.speed || 0;\n            self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;\n            self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;\n            const thresholdArr = self.pureOptions.threshold.split(\" \");\n            self.options.thresholdY = thresholdArr[0]\n              ? parseFloat(thresholdArr[0])\n              : null;\n            self.options.thresholdX = thresholdArr[1]\n              ? parseFloat(thresholdArr[1])\n              : null;\n            def.apply(self, args); // restore background image if available.\n\n            const originalStylesTag = self.$item.getAttribute(\n              \"data-jarallax-original-styles\"\n            );\n\n            if (originalStylesTag) {\n              self.$item.setAttribute(\"style\", originalStylesTag);\n            }\n\n            return true;\n          }\n\n          case \"onResize\": {\n            const defTransform = self.css(self.$item, \"transform\");\n            self.css(self.$item, {\n              transform: \"\",\n            });\n            const rect = self.$item.getBoundingClientRect();\n            self.itemData = {\n              width: rect.width,\n              height: rect.height,\n              y: rect.top + self.getWindowData().y,\n              x: rect.left,\n            };\n            self.css(self.$item, {\n              transform: defTransform,\n            });\n            break;\n          }\n\n          case \"onScroll\": {\n            const wnd = self.getWindowData();\n            const centerPercent =\n              (wnd.y +\n                wnd.height / 2 -\n                self.itemData.y -\n                self.itemData.height / 2) /\n              (wnd.height / 2);\n            const moveY = centerPercent * self.options.speedY;\n            const moveX = centerPercent * self.options.speedX;\n            let my = moveY;\n            let mx = moveX;\n            if (\n              null !== self.options.thresholdY &&\n              moveY > self.options.thresholdY\n            )\n              my = 0;\n            if (\n              null !== self.options.thresholdX &&\n              moveX > self.options.thresholdX\n            )\n              mx = 0;\n            self.css(self.$item, {\n              transform: `translate3d(${mx}px,${my}px,0)`,\n            });\n            break;\n          }\n\n          case \"initImg\":\n          case \"isVisible\":\n          case \"coverImage\":\n            return true;\n          // no default\n        }\n\n        return def.apply(self, args);\n      };\n    });\n  }\n\n  jarallaxElement(); // data-jarallax-element initialization\n\n  ready(() => {\n    if (\"undefined\" !== typeof global$1.jarallax) {\n      global$1.jarallax(document.querySelectorAll(\"[data-jarallax-element]\"));\n    }\n  });\n\n  return jarallaxElement;\n});\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/jarallax-element.js?");

/***/ }),

/***/ "./src/js/modules/jarallax.js":
/*!************************************!*\
  !*** ./src/js/modules/jarallax.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/*!\n * Jarallax v2.0.3 (https://github.com/nk-o/jarallax)\n * Copyright 2022 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/jarallax/blob/master/LICENSE)\n */\n(function (global, factory) {\n  typeof exports === \"object\" && typeof module !== \"undefined\"\n    ? (module.exports = factory())\n    : typeof define === \"function\" && define.amd\n    ? define(factory)\n    : ((global =\n        typeof globalThis !== \"undefined\" ? globalThis : global || self),\n      (global.jarallax = factory()));\n})(undefined, function () {\n  \"use strict\";\n\n  function ready(callback) {\n    if (\n      \"complete\" === document.readyState ||\n      \"interactive\" === document.readyState\n    ) {\n      // Already ready or interactive, execute callback\n      callback();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", callback, {\n        capture: true,\n        once: true,\n        passive: true,\n      });\n    }\n  }\n\n  /* eslint-disable import/no-mutable-exports */\n\n  /* eslint-disable no-restricted-globals */\n  let win;\n\n  if (\"undefined\" !== typeof window) {\n    win = window;\n  } else if (\"undefined\" !== typeof global) {\n    win = global;\n  } else if (\"undefined\" !== typeof self) {\n    win = self;\n  } else {\n    win = {};\n  }\n\n  var global$1 = win;\n\n  const { navigator } = global$1;\n  const isMobile =\n    /*#__PURE__*/ /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    );\n  let $deviceHelper;\n  /**\n   * The most popular mobile browsers changes height after page scroll and this generates image jumping.\n   * We can fix it using this workaround with vh units.\n   */\n\n  function getDeviceHeight() {\n    if (!$deviceHelper && document.body) {\n      $deviceHelper = document.createElement(\"div\");\n      $deviceHelper.style.cssText =\n        \"position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;\";\n      document.body.appendChild($deviceHelper);\n    }\n\n    return (\n      ($deviceHelper ? $deviceHelper.clientHeight : 0) ||\n      global$1.innerHeight ||\n      document.documentElement.clientHeight\n    );\n  } // Window height data\n\n  let wndH;\n\n  function updateWndVars() {\n    if (isMobile) {\n      wndH = getDeviceHeight();\n    } else {\n      wndH = global$1.innerHeight || document.documentElement.clientHeight;\n    }\n  }\n\n  updateWndVars();\n  global$1.addEventListener(\"resize\", updateWndVars);\n  global$1.addEventListener(\"orientationchange\", updateWndVars);\n  global$1.addEventListener(\"load\", updateWndVars);\n  ready(() => {\n    updateWndVars();\n  }); // list with all jarallax instances\n  // need to render all in one scroll/resize event\n\n  const jarallaxList = []; // get all parents of the element.\n\n  function getParents(elem) {\n    const parents = [];\n\n    while (null !== elem.parentElement) {\n      elem = elem.parentElement;\n\n      if (1 === elem.nodeType) {\n        parents.push(elem);\n      }\n    }\n\n    return parents;\n  }\n\n  function updateParallax() {\n    if (!jarallaxList.length) {\n      return;\n    }\n\n    jarallaxList.forEach((data, k) => {\n      const { instance, oldData } = data;\n      const clientRect = instance.$item.getBoundingClientRect();\n      const newData = {\n        width: clientRect.width,\n        height: clientRect.height,\n        top: clientRect.top,\n        bottom: clientRect.bottom,\n        wndW: global$1.innerWidth,\n        wndH,\n      };\n      const isResized =\n        !oldData ||\n        oldData.wndW !== newData.wndW ||\n        oldData.wndH !== newData.wndH ||\n        oldData.width !== newData.width ||\n        oldData.height !== newData.height;\n      const isScrolled =\n        isResized ||\n        !oldData ||\n        oldData.top !== newData.top ||\n        oldData.bottom !== newData.bottom;\n      jarallaxList[k].oldData = newData;\n\n      if (isResized) {\n        instance.onResize();\n      }\n\n      if (isScrolled) {\n        instance.onScroll();\n      }\n    });\n    global$1.requestAnimationFrame(updateParallax);\n  }\n\n  let instanceID = 0; // Jarallax class\n\n  class Jarallax {\n    constructor(item, userOptions) {\n      const self = this;\n      self.instanceID = instanceID;\n      instanceID += 1;\n      self.$item = item;\n      self.defaults = {\n        type: \"scroll\",\n        // type of parallax: scroll, scale, opacity, scale-opacity, scroll-opacity\n        speed: 0.5,\n        // supported value from -1 to 2\n        imgSrc: null,\n        imgElement: \".jarallax-img\",\n        imgSize: \"cover\",\n        imgPosition: \"50% 50%\",\n        imgRepeat: \"no-repeat\",\n        // supported only for background, not for <img> tag\n        keepImg: false,\n        // keep <img> tag in it's default place\n        elementInViewport: null,\n        zIndex: -100,\n        disableParallax: false,\n        disableVideo: false,\n        // video\n        videoSrc: null,\n        videoStartTime: 0,\n        videoEndTime: 0,\n        videoVolume: 0,\n        videoLoop: true,\n        videoPlayOnlyVisible: true,\n        videoLazyLoading: true,\n        // events\n        onScroll: null,\n        // function(calculations) {}\n        onInit: null,\n        // function() {}\n        onDestroy: null,\n        // function() {}\n        onCoverImage: null, // function() {}\n      }; // prepare data-options\n\n      const dataOptions = self.$item.dataset || {};\n      const pureDataOptions = {};\n      Object.keys(dataOptions).forEach((key) => {\n        const loweCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n\n        if (\n          loweCaseOption &&\n          \"undefined\" !== typeof self.defaults[loweCaseOption]\n        ) {\n          pureDataOptions[loweCaseOption] = dataOptions[key];\n        }\n      });\n      self.options = self.extend(\n        {},\n        self.defaults,\n        pureDataOptions,\n        userOptions\n      );\n      self.pureOptions = self.extend({}, self.options); // prepare 'true' and 'false' strings to boolean\n\n      Object.keys(self.options).forEach((key) => {\n        if (\"true\" === self.options[key]) {\n          self.options[key] = true;\n        } else if (\"false\" === self.options[key]) {\n          self.options[key] = false;\n        }\n      }); // fix speed option [-1.0, 2.0]\n\n      self.options.speed = Math.min(\n        2,\n        Math.max(-1, parseFloat(self.options.speed))\n      ); // prepare disableParallax callback\n\n      if (\"string\" === typeof self.options.disableParallax) {\n        self.options.disableParallax = new RegExp(self.options.disableParallax);\n      }\n\n      if (self.options.disableParallax instanceof RegExp) {\n        const disableParallaxRegexp = self.options.disableParallax;\n\n        self.options.disableParallax = () =>\n          disableParallaxRegexp.test(navigator.userAgent);\n      }\n\n      if (\"function\" !== typeof self.options.disableParallax) {\n        self.options.disableParallax = () => false;\n      } // prepare disableVideo callback\n\n      if (\"string\" === typeof self.options.disableVideo) {\n        self.options.disableVideo = new RegExp(self.options.disableVideo);\n      }\n\n      if (self.options.disableVideo instanceof RegExp) {\n        const disableVideoRegexp = self.options.disableVideo;\n\n        self.options.disableVideo = () =>\n          disableVideoRegexp.test(navigator.userAgent);\n      }\n\n      if (\"function\" !== typeof self.options.disableVideo) {\n        self.options.disableVideo = () => false;\n      } // custom element to check if parallax in viewport\n\n      let elementInVP = self.options.elementInViewport; // get first item from array\n\n      if (\n        elementInVP &&\n        \"object\" === typeof elementInVP &&\n        \"undefined\" !== typeof elementInVP.length\n      ) {\n        [elementInVP] = elementInVP;\n      } // check if dom element\n\n      if (!(elementInVP instanceof Element)) {\n        elementInVP = null;\n      }\n\n      self.options.elementInViewport = elementInVP;\n      self.image = {\n        src: self.options.imgSrc || null,\n        $container: null,\n        useImgTag: false,\n        // 1. Position fixed is needed for the most of browsers because absolute position have glitches\n        // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75\n        // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'\n        position: \"fixed\",\n      };\n\n      if (self.initImg() && self.canInitParallax()) {\n        self.init();\n      }\n    } // add styles to element\n    // eslint-disable-next-line class-methods-use-this\n\n    css(el, styles) {\n      if (\"string\" === typeof styles) {\n        return global$1.getComputedStyle(el).getPropertyValue(styles);\n      }\n\n      Object.keys(styles).forEach((key) => {\n        el.style[key] = styles[key];\n      });\n      return el;\n    } // Extend like jQuery.extend\n    // eslint-disable-next-line class-methods-use-this\n\n    extend(out, ...args) {\n      out = out || {};\n      Object.keys(args).forEach((i) => {\n        if (!args[i]) {\n          return;\n        }\n\n        Object.keys(args[i]).forEach((key) => {\n          out[key] = args[i][key];\n        });\n      });\n      return out;\n    } // get window size and scroll position. Useful for extensions\n    // eslint-disable-next-line class-methods-use-this\n\n    getWindowData() {\n      return {\n        width: global$1.innerWidth || document.documentElement.clientWidth,\n        height: wndH,\n        y: document.documentElement.scrollTop,\n      };\n    } // Jarallax functions\n\n    initImg() {\n      const self = this; // find image element\n\n      let $imgElement = self.options.imgElement;\n\n      if ($imgElement && \"string\" === typeof $imgElement) {\n        $imgElement = self.$item.querySelector($imgElement);\n      } // check if dom element\n\n      if (!($imgElement instanceof Element)) {\n        if (self.options.imgSrc) {\n          $imgElement = new Image();\n          $imgElement.src = self.options.imgSrc;\n        } else {\n          $imgElement = null;\n        }\n      }\n\n      if ($imgElement) {\n        if (self.options.keepImg) {\n          self.image.$item = $imgElement.cloneNode(true);\n        } else {\n          self.image.$item = $imgElement;\n          self.image.$itemParent = $imgElement.parentNode;\n        }\n\n        self.image.useImgTag = true;\n      } // true if there is img tag\n\n      if (self.image.$item) {\n        return true;\n      } // get image src\n\n      if (null === self.image.src) {\n        self.image.src =\n          \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n        self.image.bgImage = self.css(self.$item, \"background-image\");\n      }\n\n      return !(!self.image.bgImage || \"none\" === self.image.bgImage);\n    }\n\n    canInitParallax() {\n      return !this.options.disableParallax();\n    }\n\n    init() {\n      const self = this;\n      const containerStyles = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        overflow: \"hidden\",\n      };\n      let imageStyles = {\n        pointerEvents: \"none\",\n        transformStyle: \"preserve-3d\",\n        backfaceVisibility: \"hidden\",\n        willChange: \"transform,opacity\",\n      };\n\n      if (!self.options.keepImg) {\n        // save default user styles\n        const curStyle = self.$item.getAttribute(\"style\");\n\n        if (curStyle) {\n          self.$item.setAttribute(\"data-jarallax-original-styles\", curStyle);\n        }\n\n        if (self.image.useImgTag) {\n          const curImgStyle = self.image.$item.getAttribute(\"style\");\n\n          if (curImgStyle) {\n            self.image.$item.setAttribute(\n              \"data-jarallax-original-styles\",\n              curImgStyle\n            );\n          }\n        }\n      } // set relative position and z-index to the parent\n\n      if (\"static\" === self.css(self.$item, \"position\")) {\n        self.css(self.$item, {\n          position: \"relative\",\n        });\n      }\n\n      if (\"auto\" === self.css(self.$item, \"z-index\")) {\n        self.css(self.$item, {\n          zIndex: 0,\n        });\n      } // container for parallax image\n\n      self.image.$container = document.createElement(\"div\");\n      self.css(self.image.$container, containerStyles);\n      self.css(self.image.$container, {\n        \"z-index\": self.options.zIndex,\n      }); // it will remove some image overlapping\n      // overlapping occur due to an image position fixed inside absolute position element\n      // needed only when background in fixed position\n\n      if (\"fixed\" === this.image.position) {\n        self.css(self.image.$container, {\n          \"-webkit-clip-path\": \"polygon(0 0, 100% 0, 100% 100%, 0 100%)\",\n          \"clip-path\": \"polygon(0 0, 100% 0, 100% 100%, 0 100%)\",\n        });\n      }\n\n      self.image.$container.setAttribute(\n        \"id\",\n        `jarallax-container-${self.instanceID}`\n      );\n      self.$item.appendChild(self.image.$container); // use img tag\n\n      if (self.image.useImgTag) {\n        imageStyles = self.extend(\n          {\n            \"object-fit\": self.options.imgSize,\n            \"object-position\": self.options.imgPosition,\n            \"max-width\": \"none\",\n          },\n          containerStyles,\n          imageStyles\n        ); // use div with background image\n      } else {\n        self.image.$item = document.createElement(\"div\");\n\n        if (self.image.src) {\n          imageStyles = self.extend(\n            {\n              \"background-position\": self.options.imgPosition,\n              \"background-size\": self.options.imgSize,\n              \"background-repeat\": self.options.imgRepeat,\n              \"background-image\":\n                self.image.bgImage || `url(\"${self.image.src}\")`,\n            },\n            containerStyles,\n            imageStyles\n          );\n        }\n      }\n\n      if (\n        \"opacity\" === self.options.type ||\n        \"scale\" === self.options.type ||\n        \"scale-opacity\" === self.options.type ||\n        1 === self.options.speed\n      ) {\n        self.image.position = \"absolute\";\n      } // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)\n      //    discussion - https://github.com/nk-o/jarallax/issues/9\n      // 2. Check if parents have overflow scroll\n\n      if (\"fixed\" === self.image.position) {\n        const $parents = getParents(self.$item).filter((el) => {\n          const styles = global$1.getComputedStyle(el);\n          const parentTransform =\n            styles[\"-webkit-transform\"] ||\n            styles[\"-moz-transform\"] ||\n            styles.transform;\n          const overflowRegex = /(auto|scroll)/;\n          return (\n            (parentTransform && \"none\" !== parentTransform) ||\n            overflowRegex.test(\n              styles.overflow + styles[\"overflow-y\"] + styles[\"overflow-x\"]\n            )\n          );\n        });\n        self.image.position = $parents.length ? \"absolute\" : \"fixed\";\n      } // add position to parallax block\n\n      imageStyles.position = self.image.position; // insert parallax image\n\n      self.css(self.image.$item, imageStyles);\n      self.image.$container.appendChild(self.image.$item); // set initial position and size\n\n      self.onResize();\n      self.onScroll(true); // call onInit event\n\n      if (self.options.onInit) {\n        self.options.onInit.call(self);\n      } // remove default user background\n\n      if (\"none\" !== self.css(self.$item, \"background-image\")) {\n        self.css(self.$item, {\n          \"background-image\": \"none\",\n        });\n      }\n\n      self.addToParallaxList();\n    } // add to parallax instances list\n\n    addToParallaxList() {\n      jarallaxList.push({\n        instance: this,\n      });\n\n      if (1 === jarallaxList.length) {\n        global$1.requestAnimationFrame(updateParallax);\n      }\n    } // remove from parallax instances list\n\n    removeFromParallaxList() {\n      const self = this;\n      jarallaxList.forEach((data, key) => {\n        if (data.instance.instanceID === self.instanceID) {\n          jarallaxList.splice(key, 1);\n        }\n      });\n    }\n\n    destroy() {\n      const self = this;\n      self.removeFromParallaxList(); // return styles on container as before jarallax init\n\n      const originalStylesTag = self.$item.getAttribute(\n        \"data-jarallax-original-styles\"\n      );\n      self.$item.removeAttribute(\"data-jarallax-original-styles\"); // null occurs if there is no style tag before jarallax init\n\n      if (!originalStylesTag) {\n        self.$item.removeAttribute(\"style\");\n      } else {\n        self.$item.setAttribute(\"style\", originalStylesTag);\n      }\n\n      if (self.image.useImgTag) {\n        // return styles on img tag as before jarallax init\n        const originalStylesImgTag = self.image.$item.getAttribute(\n          \"data-jarallax-original-styles\"\n        );\n        self.image.$item.removeAttribute(\"data-jarallax-original-styles\"); // null occurs if there is no style tag before jarallax init\n\n        if (!originalStylesImgTag) {\n          self.image.$item.removeAttribute(\"style\");\n        } else {\n          self.image.$item.setAttribute(\"style\", originalStylesTag);\n        } // move img tag to its default position\n\n        if (self.image.$itemParent) {\n          self.image.$itemParent.appendChild(self.image.$item);\n        }\n      } // remove additional dom elements\n\n      if (self.image.$container) {\n        self.image.$container.parentNode.removeChild(self.image.$container);\n      } // call onDestroy event\n\n      if (self.options.onDestroy) {\n        self.options.onDestroy.call(self);\n      } // delete jarallax from item\n\n      delete self.$item.jarallax;\n    } // Fallback for removed function.\n    // Does nothing now.\n    // eslint-disable-next-line class-methods-use-this\n\n    clipContainer() {}\n\n    coverImage() {\n      const self = this;\n      const rect = self.image.$container.getBoundingClientRect();\n      const contH = rect.height;\n      const { speed } = self.options;\n      const isScroll =\n        \"scroll\" === self.options.type ||\n        \"scroll-opacity\" === self.options.type;\n      let scrollDist = 0;\n      let resultH = contH;\n      let resultMT = 0; // scroll parallax\n\n      if (isScroll) {\n        // scroll distance and height for image\n        if (0 > speed) {\n          scrollDist = speed * Math.max(contH, wndH);\n\n          if (wndH < contH) {\n            scrollDist -= speed * (contH - wndH);\n          }\n        } else {\n          scrollDist = speed * (contH + wndH);\n        } // size for scroll parallax\n\n        if (1 < speed) {\n          resultH = Math.abs(scrollDist - wndH);\n        } else if (0 > speed) {\n          resultH = scrollDist / speed + Math.abs(scrollDist);\n        } else {\n          resultH += (wndH - contH) * (1 - speed);\n        }\n\n        scrollDist /= 2;\n      } // store scroll distance\n\n      self.parallaxScrollDistance = scrollDist; // vertical center\n\n      if (isScroll) {\n        resultMT = (wndH - resultH) / 2;\n      } else {\n        resultMT = (contH - resultH) / 2;\n      } // apply result to item\n\n      self.css(self.image.$item, {\n        height: `${resultH}px`,\n        marginTop: `${resultMT}px`,\n        left: \"fixed\" === self.image.position ? `${rect.left}px` : \"0\",\n        width: `${rect.width}px`,\n      }); // call onCoverImage event\n\n      if (self.options.onCoverImage) {\n        self.options.onCoverImage.call(self);\n      } // return some useful data. Used in the video cover function\n\n      return {\n        image: {\n          height: resultH,\n          marginTop: resultMT,\n        },\n        container: rect,\n      };\n    }\n\n    isVisible() {\n      return this.isElementInViewport || false;\n    }\n\n    onScroll(force) {\n      const self = this;\n      const rect = self.$item.getBoundingClientRect();\n      const contT = rect.top;\n      const contH = rect.height;\n      const styles = {}; // check if in viewport\n\n      let viewportRect = rect;\n\n      if (self.options.elementInViewport) {\n        viewportRect = self.options.elementInViewport.getBoundingClientRect();\n      }\n\n      self.isElementInViewport =\n        0 <= viewportRect.bottom &&\n        0 <= viewportRect.right &&\n        viewportRect.top <= wndH &&\n        viewportRect.left <= global$1.innerWidth; // stop calculations if item is not in viewport\n\n      if (force ? false : !self.isElementInViewport) {\n        return;\n      } // calculate parallax helping variables\n\n      const beforeTop = Math.max(0, contT);\n      const beforeTopEnd = Math.max(0, contH + contT);\n      const afterTop = Math.max(0, -contT);\n      const beforeBottom = Math.max(0, contT + contH - wndH);\n      const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));\n      const afterBottom = Math.max(0, -contT + wndH - contH);\n      const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH)); // calculate on how percent of section is visible\n\n      let visiblePercent = 1;\n\n      if (contH < wndH) {\n        visiblePercent = 1 - (afterTop || beforeBottom) / contH;\n      } else if (beforeTopEnd <= wndH) {\n        visiblePercent = beforeTopEnd / wndH;\n      } else if (beforeBottomEnd <= wndH) {\n        visiblePercent = beforeBottomEnd / wndH;\n      } // opacity\n\n      if (\n        \"opacity\" === self.options.type ||\n        \"scale-opacity\" === self.options.type ||\n        \"scroll-opacity\" === self.options.type\n      ) {\n        styles.transform = \"translate3d(0,0,0)\";\n        styles.opacity = visiblePercent;\n      } // scale\n\n      if (\n        \"scale\" === self.options.type ||\n        \"scale-opacity\" === self.options.type\n      ) {\n        let scale = 1;\n\n        if (0 > self.options.speed) {\n          scale -= self.options.speed * visiblePercent;\n        } else {\n          scale += self.options.speed * (1 - visiblePercent);\n        }\n\n        styles.transform = `scale(${scale}) translate3d(0,0,0)`;\n      } // scroll\n\n      if (\n        \"scroll\" === self.options.type ||\n        \"scroll-opacity\" === self.options.type\n      ) {\n        let positionY = self.parallaxScrollDistance * fromViewportCenter; // fix if parallax block in absolute position\n\n        if (\"absolute\" === self.image.position) {\n          positionY -= contT;\n        }\n\n        styles.transform = `translate3d(0,${positionY}px,0)`;\n      }\n\n      self.css(self.image.$item, styles); // call onScroll event\n\n      if (self.options.onScroll) {\n        self.options.onScroll.call(self, {\n          section: rect,\n          beforeTop,\n          beforeTopEnd,\n          afterTop,\n          beforeBottom,\n          beforeBottomEnd,\n          afterBottom,\n          visiblePercent,\n          fromViewportCenter,\n        });\n      }\n    }\n\n    onResize() {\n      this.coverImage();\n    }\n  } // global definition\n\n  const jarallax = function (items, options, ...args) {\n    // check for dom element\n    // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n    if (\n      \"object\" === typeof HTMLElement\n        ? items instanceof HTMLElement\n        : items &&\n          \"object\" === typeof items &&\n          null !== items &&\n          1 === items.nodeType &&\n          \"string\" === typeof items.nodeName\n    ) {\n      items = [items];\n    }\n\n    const len = items.length;\n    let k = 0;\n    let ret;\n\n    for (k; k < len; k += 1) {\n      if (\"object\" === typeof options || \"undefined\" === typeof options) {\n        if (!items[k].jarallax) {\n          items[k].jarallax = new Jarallax(items[k], options);\n        }\n      } else if (items[k].jarallax) {\n        // eslint-disable-next-line prefer-spread\n        ret = items[k].jarallax[options].apply(items[k].jarallax, args);\n      }\n\n      if (\"undefined\" !== typeof ret) {\n        return ret;\n      }\n    }\n\n    return items;\n  };\n\n  jarallax.constructor = Jarallax;\n\n  const $ = global$1.jQuery; // jQuery support\n\n  if (\"undefined\" !== typeof $) {\n    const $Plugin = function (...args) {\n      Array.prototype.unshift.call(args, this);\n      const res = jarallax.apply(global$1, args);\n      return \"object\" !== typeof res ? res : this;\n    };\n\n    $Plugin.constructor = jarallax.constructor; // no conflict\n\n    const old$Plugin = $.fn.jarallax;\n    $.fn.jarallax = $Plugin;\n\n    $.fn.jarallax.noConflict = function () {\n      $.fn.jarallax = old$Plugin;\n      return this;\n    };\n  } // data-jarallax initialization\n\n  ready(() => {\n    jarallax(document.querySelectorAll(\"[data-jarallax]\"));\n  });\n\n  return jarallax;\n});\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/jarallax.js?");

/***/ }),

/***/ "./src/js/modules/mainSlider.js":
/*!**************************************!*\
  !*** ./src/js/modules/mainSlider.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => {\r\n  let mainSlider = new Swiper(\".main-Slider__body\", {\r\n    navigation: {\r\n      nextEl: \".swiper-button-next\",\r\n      prevEl: \".swiper-button-prev\",\r\n    },\r\n    loop: true,\r\n    pagination: {\r\n      el: \".swiper-pagination\",\r\n      // Буллеты\r\n      clickable: true,\r\n      //Динамические буллеты\r\n      // dynamicBullets: true,\r\n      //Кастомные буллеты\r\n      renderBullet: function (index, className) {\r\n        return (\r\n          '<span class=\"' + className + '\">' + (\"0\" + (index + 1)) + \"</span>\"\r\n        );\r\n      },\r\n    },\r\n  });\r\n});\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/mainSlider.js?");

/***/ }),

/***/ "./src/js/modules/navigation.js":
/*!**************************************!*\
  !*** ./src/js/modules/navigation.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n//?Navigation ==================\r\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\r\n  const menuLinks = document.querySelectorAll(\".menu__link[data-goto]\");\r\n  if (menuLinks.length > 0) {\r\n    menuLinks.forEach((menuLink) => {\r\n      menuLink.addEventListener(\"click\", onMenuLinkClick);\r\n    });\r\n    function onMenuLinkClick(e) {\r\n      const menuLink = e.target;\r\n      if (\r\n        menuLink.dataset.goto &&\r\n        document.querySelector(menuLink.dataset.goto)\r\n      ) {\r\n        const gotoBlock = document.querySelector(menuLink.dataset.goto);\r\n        const gotoBlockValue =\r\n          gotoBlock.getBoundingClientRect().top +\r\n          pageYOffset -\r\n          document.querySelector(\"header\").offsetHeight;\r\n        window.scrollTo({\r\n          top: gotoBlockValue,\r\n          behavior: \"smooth\",\r\n        });\r\n        e.preventDefault();\r\n      }\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/navigation.js?");

/***/ }),

/***/ "./src/js/modules/parallax.js":
/*!************************************!*\
  !*** ./src/js/modules/parallax.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\r\n  $(\".jarallax\").jarallax({\r\n    speed: 0.2,\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/parallax.js?");

/***/ }),

/***/ "./src/js/modules/webp.js":
/*!********************************!*\
  !*** ./src/js/modules/webp.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Проверка поддержки webp, добавление класса webp или no-webp для HTML\r\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\r\n  function testWebP(callback) {\r\n    var webP = new Image();\r\n    webP.onload = webP.onerror = function () {\r\n      callback(webP.height == 2);\r\n    };\r\n    webP.src =\r\n      \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\r\n  }\r\n\r\n  testWebP(function (support) {\r\n    if (support == true) {\r\n      document.querySelector(\"body\").classList.add(\"webp\");\r\n    } else {\r\n      document.querySelector(\"body\").classList.add(\"no-webp\");\r\n    }\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://gulpproject/./src/js/modules/webp.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;